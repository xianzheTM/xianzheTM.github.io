<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Java笔记7 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="&emsp;这章主要写接口，内部类和Lambda表达式。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java笔记7">
<meta property="og:url" content="http://example.com/2018/04/24/Java%E7%AC%94%E8%AE%B07/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="&emsp;这章主要写接口，内部类和Lambda表达式。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/Java%E7%AC%94%E8%AE%B07%5Cclass.png">
<meta property="article:published_time" content="2018-04-24T02:42:12.000Z">
<meta property="article:modified_time" content="2024-03-14T12:19:35.049Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Java%E7%AC%94%E8%AE%B07%5Cclass.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java笔记7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/24/Java%E7%AC%94%E8%AE%B07/" class="article-date">
  <time class="dt-published" datetime="2018-04-24T02:42:12.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Java笔记7
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>&emsp;这章主要写接口，内部类和Lambda表达式。</p>
<span id="more"></span>

<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>&emsp;假定有个Shape类，需要一个calPerimeter()方法计算各种图形的周长，但是在这个类中显然不可能将所有图形的计算周长的方法全都实现，具体的应该交给各个子类自己实现。在父类中就需要一个抽象方法，具体的方法留待子类实现。</br><br>&emsp;在抽象类中可以没有抽象方法，但是抽象方法必须在抽象类中。具体遵循下面的规则：</p>
<ul>
<li><p>抽象方法和抽象类必须使用<code>abstract</code>修饰</p>
</li>
<li><p>抽象类不能被实例化，即使里面并没有抽象方法</p>
</li>
<li><p>抽象类中可以包括普通类的各种成分（包括构造器，即使它不能被实例化，它的构造器主要是用于被子类继承）</p>
</li>
<li><p>含有抽象方法的类必须被定义成抽象类，具体包括：直接定义了一个抽象方法的类；继承了一个抽象父类但是在这个子类中并没有完全实现父类的抽象方法（即还剩抽象方法）；或实现了一个接口但没有完全实现接口包含的抽象方法。</p>
</li>
</ul>
<p>&emsp;具体代码我这里偷个懒。</br><br>&emsp;关于abstract和其他关键字的配合使用要注意，final永远不能和其一起，因为final表示不能被重写。abstract也不能用于修饰成员变量，局部变量和构造器。在和static配合使用时，不可以同时修饰某个方法，调用一个类中的没有方法体的方法肯定会出错；但是在调用一个抽象类中的静态方法是可以的；它们两个可以同时修饰内部类。private和abstract的使用也是，不能同时修饰某个方法。</br><br>&emsp;不论如何搭配使用，最简单的规则在于不能违反抽象的初衷，不能妨碍子类的重写，就比如private修饰的方法如果加上abstract，子类无法访问到也就无法进行重写，显然是不合适的。<br>&emsp;关于抽象还有一个参考链接，写的不错：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wei_zhi/article/details/52736350">https://blog.csdn.net/wei_zhi/article/details/52736350</a></p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>&emsp;抽象类是从多个类中抽象出的模板，对抽象类更彻底的抽象就是“接口”(interface)，接口里的方法全是抽象方法，而在Java8中允许在接口中定义默认方法。</br><br>&emsp;关于什么是接口，接口的作用我也说不好，贴出个知乎链接，前几个回答写的都很好;<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20111251">https://www.zhihu.com/question/20111251</a></br><br>&emsp;接口的定义方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 extends 父接口<span class="number">1</span>,父接口<span class="number">2.</span>..</span><br><span class="line">&#123;</span><br><span class="line">    零到多个常量定义</span><br><span class="line">    零到多个抽象方法定义</span><br><span class="line">    零到多个内部类，内部接口，内部枚举</span><br><span class="line">    零到多个默认方法或类方法定义(这里用类方法这个名字貌似不太合适，其实就是静态方法)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;修饰符可以是public或者默认的包访问控制权限，接口的命名与类的命名类似，一个源文件中只能有一个public的接口，且名字应和源文件名字相同。</br><br>&emsp;由于接口定义的是一种规范，是完全抽象出来的东西，因此不能有构造器和初始化块。作为规范，接口是公共的，所以接口里的东西都是公共的，不论是否加上了public修饰符。</br><br>&emsp;对于接口中常量，系统会自动加上public static final这三个修饰符，同时，这也意味着只能在定义是指定默认值。</br><br>&emsp;接口中定义的抽象方法在没有关键字abstract时也会自动加上，类方法和默认方法必须要有方法体。接口中的内部类，内部接口，内部枚举都采用public static修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Output</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX_CACHE_LINE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(String msg)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... msgs)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String msg : msgs) &#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认的test()方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">staticTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;接口里的类方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;对于默认方法，必须使用default修饰，不能使用static修饰，相对的接口中的类方法只能用static修饰，不能用default修饰。同样，他俩都会被加上public。</p>
<h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p>&emsp;接口的继承不同与父类的继承，它支持一个接口继承多个直接父接口，通过extends关键字，之间用逗号隔开。</p>
<h2 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h2><p>&emsp;接口不可以用来创建实例，但是可以用来声明引用类型变量，但是这个引用类型变量必须引用到接口的实现类的实现，意思是：假定用接口A声明引用类型变量C，那么这个C引用的对象必须是根据A实现的类B的对象。接口的主要用途还是被实现类来实现。用途：</p>
<ul>
<li>定义变量或者用于强制类型转换</li>
<li>调用接口中的常量</li>
<li>被其他类实现</li>
</ul>
<p>&emsp;一个类可以实现一个或多个接口。子类继承父类使用extends关键字，而实现接口用implements关键字，implements必须放在extends后。一个类使用了implements关键字后，必须实现这些接口中定义的全部抽象方法，否则该类将保留继承到的抽象方法，所以要定义为抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getProduceTime</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">Output</span>,Product&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] printData=<span class="keyword">new</span> <span class="title class_">String</span>[MAX_CACHE_LINE];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> dataNum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (dataNum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打印机打印：&quot;</span>+printData[<span class="number">0</span>]);</span><br><span class="line">            System.arraycopy(printData, <span class="number">1</span>, printData, <span class="number">0</span>, --dataNum);<span class="comment">//从指定数组的指定位置开始复制到指定数组的指定位置，length为复制长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dataNum&gt;=MAX_CACHE_LINE)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输出队列已满，添加失败&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//把打印数据添加到队列中，以保存的数据量加一</span></span><br><span class="line">            printData[dataNum++]=msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getProduceTime</span><span class="params">()</span>&#123;<span class="comment">//实现接口中的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">45</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Printer对象，当成Output使用</span></span><br><span class="line">        Output o=<span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">        o.getData(<span class="string">&quot;天国之秋&quot;</span>);</span><br><span class="line">        o.getData(<span class="string">&quot;世界文明史&quot;</span>);</span><br><span class="line">        o.out();</span><br><span class="line">        o.getData(<span class="string">&quot;文明的冲突与世界历史的重建&quot;</span>);</span><br><span class="line">        o.getData(<span class="string">&quot;21世纪资本论&quot;</span>);</span><br><span class="line">        o.out();</span><br><span class="line">        o.print(<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;猪八戒&quot;</span>,<span class="string">&quot;沙僧&quot;</span>);</span><br><span class="line">        o.test();</span><br><span class="line">        <span class="comment">//创建一个Printer对象，当成Product使用</span></span><br><span class="line">        Product p=<span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">        System.out.println(p.getProduceTime());</span><br><span class="line">        Object obj=p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;从上面的程序可以看出，<code>Product p=new Printer();</code>Product接口修饰了其实现类的对象，同理，Object也是如此。对象o也可以直接使用接口中的默认方法。</br><br>&emsp;由于接口里的方法都是public的，所以在实现类中的方法也必须是public的。</p>
<h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><p>&emsp;接口和抽象类都具有一下特征：</p>
<ul>
<li>接口和抽象类都不能被实例化，用于被其他类实现和继承</li>
<li>接口和抽象类都包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法</li>
</ul>
<p>&emsp;但是接口和抽象类有着非常大的区别：<br>&emsp;接口是一种规范，最简单来说，它充当在多个模块中间的耦合标准。例如，接口A规定了需要实现哪些方法和具有的常量，那么实现类B就会根据接口实现，而另一个类C参照接口就知道可以调用B中的哪些方法。如果是系统与外界交互，那么接口就能告诉系统先实现什么方法，也告诉用户可以使用哪些方法。总之，接口的作用就是告诉一边要做什么，另一边能做什么。而抽象类则体现了模板的思想，算是一种中间产品。在这种根本思想的差别外还在用法上存在差别：</p>
<ul>
<li>接口只能包含抽象方法和默认方法，抽象类则可以包含普通方法</li>
<li>接口不能定义静态方法(JDK8之前)，抽象类可以。</li>
<li>接口中只能有静态常量，不能有普通成员变量，抽象类则两种都可以</li>
<li>接口中不能有构造器，抽象类则有，虽然不能用</li>
<li>接口中不能有初始化块，抽象类则可以</li>
</ul>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>&emsp;假定程序中有个Computer类需要一个输出的设备，一般可以直接组合（即包含）一个Printer类(上面的代码)在里面，修改Computer类就可以，但是如果有多个类组合了Printer类的话，一旦Printer类要被替代，那就要修改所有类中的Printer类，非常麻烦。</br><br>&emsp;但是假如在Computer中组合一个Output（接口）的类，那就会很方便。因为它需要的是一个符合Output接口规范的类，所以不论Printer类还是修改后的BatterPrinter类，只要符合规范就可以直接被使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Output out;<span class="comment">//用接口修饰成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">(Output out)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.out = out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyIn</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        out.getData(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        out.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;再贴出Output的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Output</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX_CACHE_LINE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(String msg)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... msgs)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String msg : msgs) &#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;同时，在Computer类中也不负责具体的Output接口的实现类的对象产生，这部分工作交给了一个Output工厂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Output <span class="title function_">getOutput</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">OutputFactory</span> <span class="variable">of</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputFactory</span>();</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(of.getOutput());</span><br><span class="line">        c.keyIn(<span class="string">&quot;天国之秋&quot;</span>);</span><br><span class="line">        c.keyIn(<span class="string">&quot;阿拉伯的劳伦斯&quot;</span>);</span><br><span class="line">        c.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;在OutputFactory这个类中，getOutput的返回值是符合Output接口的Printer类。这个类被传入computer的构造函数，现在Computer类的对象c中就具有了Printer()对象。c.keyIn则调用Printer()对象的getData方法，将文字存储进去。c.print()则调用了out()方法。</br><br>&emsp;如果需要改进Printer()方法，则只要将getOutput的返回值改为改进后的类的对象。不需要担心在调用c.keyIn方法时不兼容，因为getOutput的返回类型是Output的，computer的构造器接受的也是Output的，只要符合Output接口规范的类在里面都可以使用。</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>&emsp;接口还有一个妙用，请看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span>&#123;<span class="comment">//Command接口，要求接受一个数组</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] target)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessArray</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] target , Command cmd)</span>&#123;<span class="comment">//注意这里传入了Command接口的实现对象</span></span><br><span class="line">        cmd.process(target);<span class="comment">//这里调用了传入cmd的process方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ProcessArray</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">        <span class="type">int</span>[] target = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        pa.process(target,<span class="keyword">new</span> <span class="title class_">PrintCommand</span>());</span><br><span class="line">        pa.process(target,<span class="keyword">new</span> <span class="title class_">AddCommand</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;假定根据Command接口实现了PrintCommand和AddCommand类，一个具有打印数组的方法，一个具有累加数组的方法。根据ProcessArray类中的方法，就可以实现不同的方法。这样子就实现了ProcessArray类中的process方法与真正的处理方法的分离。</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>&emsp;内部类主要有以下作用和区别：</p>
<ul>
<li>当一个类脱离另一个类后就完全没有意义时，则可以作为内部类，这样有更好的封装</li>
<li>内部类可以直接访问外部类的成员，因为它自己也是外部类的成员，但是不能倒过类访问</li>
<li>匿名内部类更适合创建一次性的类</li>
<li>因为是外部类的成员，所以可以用private，protected,static修饰</li>
<li>非静态内部类不能拥有静态成员</li>
</ul>
<h2 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h2><p>&emsp;内部类可以放在类内任何地方，包括方法体中（局部内部类）。成员内部类是一种与成员变量类似的类成员，但局部内部类和匿名内部类则不是。</br><br>&emsp;当编译含有内部类的外部类时，会产生两个class文件，一个外部类的，还有个内部类的，名字是外部类和内部类的名字用<code>$</code>连起来，不管是静态还是非静态的内部类。</br><br>&emsp;内部类的对象可以访问外部类的私有数据，这是因为内部类的对象保存了它所寄生的外部类的对象的引用，调用非静态内部类的实例方法时，必须有一个非静态内部类实例，而非静态内部类必须寄生在外部类实例中。</br><br>&emsp;当非静态内部类的某个方法访问某个变量时，会先在改方法中查找变量，然后是内部类，最后是外部类。如果外部类和内部类的成员变量存在重名情况，访问外部类则要通过OuterClass.this.membername使用，内部类则是this.membername。</br><br>&emsp;外部类是不能直接访问内部类的。因为内部类的存在是依附于外部类，但是反过来不一定，内部类外一定有外部类，但是外部类中不一定有内部类。所以，当要访问内部类时，要显式的创建内部类。</br><br>&emsp;根据静态成员不能访问非静态成员的规则，外部类的静态成员不能访问非静态内部类的成员。非静态内部类中也不允许定义静态成员。</br><br>&emsp;为什么非静态内部类中不可定义静态成员，是因为，对于外部类来说，内部类也就是个成员，和其他的成员变量没有区别。在前面说过，内部类和外部类的class文件是分开的，当加载类时也是分开加载的，先加载外部类，如果要实例化外部类的话再加载内部类。因此，如果要有内部类（可以当成一个普通的外部类方法），没有外部类实例是不行的。但是，JVM要求所有的静态变量要在对象创建之前加载这就是矛盾所在。也有从另一个角度看问题的解释：<a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000000304968">https://segmentfault.com/q/1010000000304968</a>。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>&emsp;用static修饰的内部类变成了属于外部类所有，不再和外部类的实例绑在一起。</br><br>&emsp;静态内部类可以包含静态成员。静态内部类可以访问外部的静态成员，但是外部的非静态成员还是不能访问。因为，静态内部类是寄生在外部类中的，并不和某个外部类对象产生关联，没有持有他的引用，也就找不到相关的成员变量。</br><br>&emsp;在接口中也是可以定义内部类的，但只能是static的。</p>
<h2 id="使用内部类"><a href="#使用内部类" class="headerlink" title="使用内部类"></a>使用内部类</h2><h3 id="在外部类中使用内部类"><a href="#在外部类中使用内部类" class="headerlink" title="在外部类中使用内部类"></a>在外部类中使用内部类</h3><p>&emsp;在外部类中使用内部类没有什么特别的地方，直接在外部类中声明并使用内部类就行。</p>
<h3 id="在外部类以外的地方"><a href="#在外部类以外的地方" class="headerlink" title="在外部类以外的地方"></a>在外部类以外的地方</h3><p>&emsp;如果希望在外部类使用内部类（包括静态和非静态），则内部类不能有private。具体语法格式：<code>OuterClass.InnerClass varName=new OuterInatance.new InnerConstructor()</code>，首先需要用内部类来声明一个内部类的引用变量，然后要在外部类实例中再new一个内部类实例。非静态内部类的构造器必须要在外部类的实例中调用。</br><br>&emsp;如果需要创建内部类的子类，则尤其要注意上面一点。因为子类在调用自生构造器之前会调用父类的构造器，所以必须保证子类可以访问到父类的构造器，这就要求必须存在一个外部类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">Out</span>.In&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubClass</span><span class="params">(Out out)</span>&#123;</span><br><span class="line">        out.<span class="built_in">super</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;上面代码的意思就是，在调用SubClass类的父类In类的构造器时，需要一个外部类的实例。非静态内部类的子类不一定是内部类，但是同样要保留一个引用，该引用指向父类的外部类的对象。当内部类的子类的对象存在时，也一定存在外部类的对象。</p>
<h3 id="在外部类以外使用静态类"><a href="#在外部类以外使用静态类" class="headerlink" title="在外部类以外使用静态类"></a>在外部类以外使用静态类</h3><p>&emsp;创建静态内部类实例的语法和非静态内部类的语法是类似的：<code>OuterClass.InnerClass varName=new OuterClass.InnerConstructor()</code>，最明显的区别就是不需要通过外部类的实例调用内部类的构造器了。同样，内部类的子类的使用也更简单，无需外部类实例。</p>
<h3 id="一点小疑问"><a href="#一点小疑问" class="headerlink" title="一点小疑问"></a>一点小疑问</h3><p>&emsp;内部类是外部类的一个成员，那么能否像重写方法一样在外部类的子类中重写内部类呢？是不能的。因为前面写过，内部类的类名不只是它的名字，而是外部类和内部类用’$’连起来的，父类的内部类名字是OuterA$InnerB.class，子类的名字就可能是OuterC$InnerB.class，它们实际不重名。</p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>&emsp;如果把内部类放在方法里，那就是局部内部类。它的上一级单元是方法，所以用static修饰这种内部类是没有意义的。与局部变量类似，局部内部类也不能用static和public等修饰。关于局部内部类的所有操作都和局部变量类似，只能在方法内部有用。请看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerBase</span>&#123;</span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerSub</span> <span class="keyword">extends</span> <span class="title class_">InnerBase</span>&#123;</span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        InnerSub is=<span class="keyword">new</span> <span class="title class_">InnerSub</span>();</span><br><span class="line">        is.a=<span class="number">5</span>;</span><br><span class="line">        is.b=<span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;InnerSub的对象的a和b的实例变量是：&quot;</span>+is.a+<span class="string">&quot;,&quot;</span>+is.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;有意思的是生成的class文件<img src="/Java%E7%AC%94%E8%AE%B07%5Cclass.png" alt="class">，针对局部内部类和其子类，它们的生成class中间都有个数字，这是因为一个类中可能存在多个方法语句，每个语句中有种同名的局部内部类，所以需要加以区分。</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>&emsp;定义匿名内部类的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 实现接口() | 父类构造器(实参列表)&#123;</span><br><span class="line">    <span class="comment">//类体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;直接给出代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Product</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span>;</span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Product P)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购买了一个&quot;</span> + P.getName() + <span class="string">&quot;,花掉了&quot;</span> + P.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnonymousTest</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousTest</span>();</span><br><span class="line">        ta.test(<span class="keyword">new</span> <span class="title class_">Product</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">567.8</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;配件&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;是不是觉得奇怪，怎么和上面的语法格式不太一样？匿名内部类因为使用了new关键字，所以会创建对象，只不过是没有引用变量显式的指向它，而且，匿名内部类是实现接口或调用父类构造器的，然而这里却没有出现接口的实现类和子类的名字，所以是匿名的。可以简单理解为，在不实现接口或继承父类的情况下，创建基于它们的对象。</br><br>&emsp;再来看上面的代码，test()方法需要一个Product接口实现类的对象，但是因为内容都很简单，为此实现一个类出来不划算，所以采用了匿名内部类。ta.test()接受了匿名内部类的对象。</br><br>&emsp;关于匿名内部类有些注意点：</p>
<ul>
<li>匿名内部类因为必须创建对象，所以不能是抽象的，即必须完全实现接口或父类的抽象方法。只能在接口和父类中二选一，也不支持多个实现或继承。</li>
<li>支持对父类的非抽象方法进行重写</li>
<li>匿名内部类不能定义构造器，但是可以有初始化块。同时，因为不能定义构造器，所以只有默认的无参数构造器，所以在<code>new Product()</code>中没有参数。但是，如果是父类的匿名内部类，那么就会有与父类相似的构造器，具有构造器的形参列表。</li>
</ul>
<p>&emsp;在Java8之前，局部内部类，匿名内部类访问的局部变量必须是final修饰的，Java8之后不需要这样了。在Java8中，这种变量可以使用final修饰，也可以不使用，但是都是按照final的方式来用的。因此被匿名内部类和局部内部类访问的局部变量是不能重新赋值的。</p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>&emsp;Lam表达式支持将代码块作为方法参数，允许使用更简洁的代码来创建只有一个抽象方法的接口（函数式接口）。</br><br>&emsp;先再看下命令模式中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span>&#123;<span class="comment">//Command接口，要求接受一个数组</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] target)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessArray</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] target , Command cmd)</span>&#123;<span class="comment">//注意这里传入了Command接口的实现对象</span></span><br><span class="line">        cmd.process(target);<span class="comment">//这里调用了传入cmd的process方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ProcessArray</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">        <span class="type">int</span>[] target = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        pa.process(target,<span class="keyword">new</span> <span class="title class_">PrintCommand</span>());</span><br><span class="line">        pa.process(target,<span class="keyword">new</span> <span class="title class_">AddCommand</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proocess</span><span class="params">(<span class="type">int</span>[] target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> tmp : target)&#123;</span><br><span class="line">            sum=sum+tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组元素的总和：&quot;</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;但是上面的代码需要我分别实现各个操作过程。接着试着用匿名内部类来改写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ProcessArray</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">        <span class="type">int</span>[] target = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        pa.procsee(target,<span class="keyword">new</span> <span class="title class_">Command</span>&#123;            <span class="comment">//使用匿名内部类</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] target)</span>&#123;</span><br><span class="line">                <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> tmp : target)&#123;</span><br><span class="line">                    sum=sum+tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;数组元素的总和：&quot;</span>+sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;注意有两个process，ProcessArray和接口中的，是不一样的。ProcessArray的对象的process方法接受数组和Command接口的实现类的对象，然后调用这个对象的process方法处理数组。而用匿名内部类时，直接根据接口创建一个对象。这样可以避免不必要的接口实现。</br><br>&emsp;而使用Lambda可以将匿名内部类进一步简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProcessArray</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">3</span>, -<span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        pa.process(array, (<span class="type">int</span>[] target) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> tmp : target) &#123;</span><br><span class="line">                sum = sum + tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组元素的总和：&quot;</span> + sum);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&emsp;从上面的代码来看，Lambda表达式仍然是创建了一个对象，只是省略了非常多的东西，不需要new Xxx(){}，也不需要指出重写的方法的名字和返回值类型（上面的代码没用到），只要括号和括号中的参数列表。</br><br>&emsp;形参列表允许省略参数类型，如果只有一个参数，连括号也可以省略。代码块如果只要一条语句，花括号也可以省略。Lambda代码块只有一条return语句。如果，代码块中只有一条省略了return的语句，那就会直接返回这条语句的值。</br><br>&emsp;先看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Eatable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">taste</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(String weather)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Addable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Eatable e)</span> &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        e.taste();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Flyable f)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我正在驾驶：&quot;</span> + f);</span><br><span class="line">        f.fly(<span class="string">&quot;【碧空如洗的晴日】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Addable add)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5和3的和为：&quot;</span> + add.add(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LambdaTest</span> <span class="variable">lq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaTest</span>();</span><br><span class="line">        lq.eat(() -&gt; System.out.println(<span class="string">&quot;苹果的味道不错&quot;</span>));</span><br><span class="line">        lq.drive(weather -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;今天天气是：&quot;</span> + weather);</span><br><span class="line">            System.out.println(<span class="string">&quot;直升机平稳飞行&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        lq.test((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;先来看看<code>lq.eat(() -&gt; System.out.println(&quot;苹果的味道不错&quot;));</code>这句的意思，在LambdaQs的类体中查看eat()方法，这个方法需要一个Eatable接口的实现类的对象，下面的也是。Lambda表达式实际上会被当成一个任意类型的对象，具体是何种类型取决于运行环境的需要。但是这里面具体是如何运行的呢？</p>
<h2 id="Lambda表达式与函数式接口"><a href="#Lambda表达式与函数式接口" class="headerlink" title="Lambda表达式与函数式接口"></a>Lambda表达式与函数式接口</h2><p>&emsp;Lambda表达式的类型（也被叫“目标类型”），必须是“函数式接口”，这种接口只有一个抽象方法，但是可以包含多个默认方法，类方法。Java8还提供了@FunctionalInterface注解。</br><br>&emsp;以Java本身提供的Runnable接口为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Runable接口中只包含一个无参数的方法</span></span><br><span class="line"><span class="comment">//Lambda表达式代表的匿名方法实现了Runnable接口中唯一的，无参数的方法</span></span><br><span class="line"><span class="comment">//因此下面的Lambda表达式创建了一个对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;Lambda表达式实现的是<strong>特定函数式接口中的唯一方法</strong>。注意这句话的意思。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;如果这样写，就会得到错误，因为Object不是一个函数式接口。如果要保证有一个明确的函数式接口，有三种常见方式：</p>
<ul>
<li>将Lambda表达式赋值给函数式接口类型的变量</li>
<li>将Lambda表达式作为函数式接口的参数传给某个方法</li>
<li>使用函数式接口对Lambda表达式进行强制类型转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> (Runnable)() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;接着回过头再来看一下Lambda表达式到底是如何来的。</p>
<h3 id="Lambda的演变"><a href="#Lambda的演变" class="headerlink" title="Lambda的演变"></a>Lambda的演变</h3><h4 id="最初的命令模式"><a href="#最初的命令模式" class="headerlink" title="最初的命令模式"></a>最初的命令模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span>&#123;<span class="comment">//Command接口，要求接受一个数组</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] target)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessArray</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] target , Command cmd)</span>&#123;<span class="comment">//注意这里传入了Command接口的实现对象</span></span><br><span class="line">        cmd.process(target);<span class="comment">//这里调用了传入cmd的process方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ProcessArray</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">        <span class="type">int</span>[] target = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        pa.process(target,<span class="keyword">new</span> <span class="title class_">PrintCommand</span>());</span><br><span class="line">        pa.process(target,<span class="keyword">new</span> <span class="title class_">AddCommand</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proocess</span><span class="params">(<span class="type">int</span>[] target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> tmp : target)&#123;</span><br><span class="line">            sum=sum+tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组元素的总和：&quot;</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ProcessArray</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">        <span class="type">int</span>[] target = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        pa.procsee(target,<span class="keyword">new</span> <span class="title class_">Command</span>&#123;            <span class="comment">//使用匿名内部类</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] target)</span>&#123;</span><br><span class="line">                <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> tmp : target)&#123;</span><br><span class="line">                    sum=sum+tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;数组元素的总和：&quot;</span>+sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;匿名内部类不过是把接口中的抽象方法实现，但是没有具体的类而已。</p>
<h4 id="Lambda表达式的演变"><a href="#Lambda表达式的演变" class="headerlink" title="Lambda表达式的演变"></a>Lambda表达式的演变</h4><ol>
<li>把外面的壳子去掉</li>
</ol>
<p>&emsp;只保留参数列表和方法题。参数和方法题之间用‘-&gt;’链接。为什么可以去掉？因为<strong>特定函数式接口中的唯一方法</strong>这句话，只有一个方法，当然可以知道省略的是哪个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ProcessArray</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">        <span class="type">int</span>[] target = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        pa.procsee(target,<span class="keyword">new</span> <span class="title class_">Command</span>&#123;            <span class="comment">//使用匿名内部类</span></span><br><span class="line">            (<span class="type">int</span>[] target)-&gt;&#123;</span><br><span class="line">                <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> tmp : target)&#123;</span><br><span class="line">                    sum=sum+tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;数组元素的总和：&quot;</span>+sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>把return和{}去掉</li>
</ol>
<p>&emsp;这里不能去，跳过</p>
<ol start="3">
<li>把参数类型和圆括号去掉</li>
</ol>
<p>&emsp;只有一个参数时可以去掉，类似int[] target这样的，括号也不能去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ProcessArray</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">        <span class="type">int</span>[] target = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        pa.procsee(target,<span class="keyword">new</span> <span class="title class_">Command</span>&#123;            <span class="comment">//使用匿名内部类</span></span><br><span class="line">                target-&gt;&#123;</span><br><span class="line">                <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> tmp : target)&#123;</span><br><span class="line">                    sum=sum+tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;数组元素的总和：&quot;</span>+sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>直接把表达式传递进去或者作为参数传递进去</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ProcessArray</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">        <span class="type">int</span>[] target = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        pa.procsee(target, target-&gt;&#123;</span><br><span class="line">                <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> tmp : target)&#123;</span><br><span class="line">                    sum=sum+tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;数组元素的总和：&quot;</span>+sum);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;再把变量名字改一下就和上面的一样了（上面的没省略变量类型）。这种演变分的方法请看链接<a target="_blank" rel="noopener" href="http://how2j.cn/k/lambda/lambda-lamdba-tutorials/697.html#nowhere">http://how2j.cn/k/lambda/lambda-lamdba-tutorials/697.html#nowhere</a>，非常不错的教程。</br><br>&emsp;仔细观察发现，要想使用Lambda表达式，最重要的就是Lambda实现的匿名方法的参数列表要和函数式接口中唯一的抽象方法的接口一样。这意味这在前面提到过的Runnable强制转换可以用来改变Lambda表达式的用处，只要参数列表是一样的，就可以通过强制转换通用。&lt;&#x2F;br?<br>&emsp;Lambda表达式的本质是用简洁的语法来创建函数式接口的实例。</p>
<h2 id="方法引用和构造器"><a href="#方法引用和构造器" class="headerlink" title="方法引用和构造器"></a>方法引用和构造器</h2><p>&emsp;当Lambda表达式只有一条语句时还可以使用方法引用和构造器引用。</p>
<h3 id="引用类方法"><a href="#引用类方法" class="headerlink" title="引用类方法"></a>引用类方法</h3><p>&emsp;定义了如下函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Converter</span>&#123;</span><br><span class="line">    Integer <span class="title function_">convert</span><span class="params">(String from)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;该接口的要求是传入一个字符串并将其转化为Integer类型。分析后发现，不需要单独将实现类写出来，因为可以直接使用<code>Integer.valueOf</code>方法转化。下面的代码使用Lambda表达式创建一个Converter接口的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Converter</span> <span class="variable">converter1</span> <span class="operator">=</span> from -&gt; Integer.valueOf(from);</span><br></pre></td></tr></table></figure>

<p>&emsp;接下来使用这个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> converter1.convert(<span class="string">&quot;99&quot;</span>);</span><br><span class="line">System.out.println(val);</span><br></pre></td></tr></table></figure>

<p>&emsp;由于Lambda表达式创建了一个Converter对象，这个对象具有Lambda表达式代表的匿名方法，所以可以将参数传进去调用这个对象的方法。</br><br>&emsp;对于这里的Lambda表达式，引用了Integer类的valueOf()类方法，所以还可以换种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Converter</span> <span class="variable">converter1</span> <span class="operator">=</span> Integer::valueOf;</span><br></pre></td></tr></table></figure>

<p>&emsp;乍看肯定会说卧槽，这是怎么变得。我觉得要是直接从接口写出来这种有点转不过弯，还是一步步来吧。上面的类引用方法简单来说就是使用某个类的类方法来实现接口中的抽象方法。</p>
<h3 id="引用特定对象的实例方法"><a href="#引用特定对象的实例方法" class="headerlink" title="引用特定对象的实例方法"></a>引用特定对象的实例方法</h3><p>&emsp;现在还是用上面的那个接口，只不过要求变了，要求输入一个字符串，然后返回在给定字符串中的索引值（Integer）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Converter</span> <span class="variable">converter2</span> <span class="operator">=</span> from -&gt; <span class="string">&quot;hellojava&quot;</span>.indexOf(from);  <span class="comment">//使用现成的indexOf方法</span></span><br></pre></td></tr></table></figure>

<p>&emsp;原本indexOf方法返回的是int类型，这里自动装箱为Interger。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> converter2.convert(<span class="string">&quot;ll&quot;</span>);</span><br><span class="line">System.out.println(val);</span><br></pre></td></tr></table></figure>

<p>&emsp;结果为2，也可以采用下面的简写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Converter</span> <span class="variable">converter1</span> <span class="operator">=</span> <span class="string">&quot;hellojava&quot;</span>::indexOf;</span><br></pre></td></tr></table></figure>

<p>&emsp;上面的实例引用方法就是使用具体的实例的方法来实现接口中的抽象方法。</p>
<h3 id="引用某类对象的实例方法"><a href="#引用某类对象的实例方法" class="headerlink" title="引用某类对象的实例方法"></a>引用某类对象的实例方法</h3><p>&emsp;这回换一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyTest</span>&#123;</span><br><span class="line">    String <span class="title function_">test</span><span class="params">(String a,<span class="type">int</span> b,<span class="type">int</span> c)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;根据test()抽象方法，使用Lambda表达式创建一个MyTest对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyTest</span> <span class="variable">mt</span> <span class="operator">=</span> (a,b,c) -&gt; a.substring(b,c);  <span class="comment">//截取a字符串，从b开始，到c结束，不包括c</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> mt.test(<span class="string">&quot;hello java&quot;</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>&emsp;该代码的Lambda部分可以改写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyTest</span> <span class="variable">mt</span> <span class="operator">=</span> String::substring;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> mt.test(<span class="string">&quot;hello java&quot;</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>&emsp;这里与上面类似，只不过不是具体的哪个对象的方法，而是某类对象的实例方法。注意和引用类方法的区别，从<code>a.substring(b,c)</code>可以看出，它是实例方法。传入的三个参数，第一个作为调用者，后面两个作为substring的参数。</p>
<h3 id="引用构造器"><a href="#引用构造器" class="headerlink" title="引用构造器"></a>引用构造器</h3><p>&emsp;再换一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">YourTest</span>&#123;</span><br><span class="line">    JFrame <span class="title function_">win</span><span class="params">(String title)</span>;  <span class="comment">//JFrame是一个类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;该抽象方法要求根据String参数返回一个JFrame对象，Lambda代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Yourtest</span> <span class="variable">yt</span> <span class="operator">=</span> (String a) -&gt; <span class="keyword">new</span> <span class="title class_">JFrame</span>(a);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JFrame</span> <span class="variable">jf</span> <span class="operator">=</span> yt.win(<span class="string">&quot;我的窗口&quot;</span>);</span><br><span class="line">System.out.println(jf);</span><br></pre></td></tr></table></figure>

<p>&emsp;进一步简略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Yourtest</span> <span class="variable">yt</span> <span class="operator">=</span> JFrame::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;不需要写明调用哪个构造器，就如同正常调用构造器一样，是根据传入的参数来决定用哪个构造器。</p>
<h2 id="Lambda表达式和匿名内部类的联系和区别"><a href="#Lambda表达式和匿名内部类的联系和区别" class="headerlink" title="Lambda表达式和匿名内部类的联系和区别"></a>Lambda表达式和匿名内部类的联系和区别</h2><p>&emsp;通过上面一系列的使用，可以发现匿名内部类和Lambda表达式非常像，Lambda可以说是匿名内部类的简化版。</br><br>&emsp;存在如下相同点：</p>
<ul>
<li>都可以直接访问局部变量（之后不能改变）和外部类的成员变量</li>
<li>都可以直接调用从接口继承的默认方法</li>
</ul>
<p>&emsp;也有很多区别：</p>
<ul>
<li>匿名内部类可以为任意接口创建实例，只要实现全部抽象方法即可；Lambda表达式只能为函数式接口创建实例</li>
<li>匿名内部类可以为抽象类或者普通类创建实例，但是Lambda表达式都不能</li>
<li>匿名内部类实现的抽象方法允许调用接口中的抽象方法，但是Lambda表达式不允许</li>
</ul>
<h1 id="一点补充知识"><a href="#一点补充知识" class="headerlink" title="一点补充知识"></a>一点补充知识</h1><blockquote>
<p>&emsp;在Java8之前，局部内部类，匿名内部类访问的局部变量必须是final修饰的，Java8之后不需要这样了。在Java8中，这种变量可以使用final修饰，也可以不使用，但是都是按照final的方式来用的。因此被匿名内部类和局部内部类访问的局部变量是不能重新赋值的。</p>
</blockquote>
<blockquote>
<p>&emsp;存在如下相同点：</p>
<ul>
<li>都可以直接访问局部变量（之后不能改变）和外部类的成员变量</li>
<li>都可以直接调用从接口继承的默认方法</li>
</ul>
</blockquote>
<p>&emsp;这两个地方都写到，局部内部类，匿名内部类，Lambda表达式访问<strong>外面</strong>的局部变量时，这些变量要是final的，即使没有这么写，之后也不能更改。大概的原因是，外部的局部变量会进行值传递，如果内部修改或外部修改值就会造成数据混乱。具体请看链接：<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21395848">https://www.zhihu.com/question/21395848</a><br><a target="_blank" rel="noopener" href="http://cuipengfei.me/blog/2013/06/22/why-does-it-have-to-be-final/">http://cuipengfei.me/blog/2013/06/22/why-does-it-have-to-be-final/</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hapjin/p/5744478.html">https://www.cnblogs.com/hapjin/p/5744478.html</a><br>还有一篇关于闭包的：<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24084277/answer/110176733">https://www.zhihu.com/question/24084277/answer/110176733</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/24/Java%E7%AC%94%E8%AE%B07/" data-id="cltr7hcaa00260kun4ac8d3sr" data-title="Java笔记7" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/04/24/Python%E7%AC%94%E8%AE%B01/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Python笔记1
        
      </div>
    </a>
  
  
    <a href="/2018/04/19/Java%E7%AC%94%E8%AE%B06/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java笔记6</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenCV/" rel="tag">OpenCV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VS/" rel="tag">VS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/VS/" style="font-size: 10px;">VS</a> <a href="/tags/cpp/" style="font-size: 17.5px;">cpp</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 15px;">汇编</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 12.5px;">网络</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 12.5px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/08/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</a>
          </li>
        
          <li>
            <a href="/2018/11/03/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-2/">网络原理(2)</a>
          </li>
        
          <li>
            <a href="/2018/10/26/html%E6%80%BB%E7%BB%93/">html总结</a>
          </li>
        
          <li>
            <a href="/2018/10/25/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-1/">网络原理(1)</a>
          </li>
        
          <li>
            <a href="/2018/08/18/Java%E7%9A%84JDBC/">Java的JDBC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>