<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>内存空间分配 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="在计算机总线一文中介绍了内存地址空间，现在说明在C++中如何进行内存分配。">
<meta property="og:type" content="article">
<meta property="og:title" content="内存空间分配">
<meta property="og:url" content="http://example.com/2018/01/30/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="在计算机总线一文中介绍了内存地址空间，现在说明在C++中如何进行内存分配。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%5CC%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://example.com/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%5CC++%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://example.com/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%5C%E6%AF%94%E8%BE%83.jpg">
<meta property="og:image" content="http://example.com/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%5C9.3.png">
<meta property="article:published_time" content="2018-01-30T01:41:28.000Z">
<meta property="article:modified_time" content="2024-03-14T12:19:35.417Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%5CC%E7%BB%93%E6%9E%84.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-内存空间分配" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/01/30/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D/" class="article-date">
  <time class="dt-published" datetime="2018-01-30T01:41:28.000Z" itemprop="datePublished">2018-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      内存空间分配
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在计算机总线一文中介绍了内存地址空间，现在说明在C++中如何进行内存分配。</p>
<span id="more"></span>

<p>一个C&#x2F;C++的程序占用的内存分为以下几个部分：</p>
<p>1.栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等，操作方式类似与数据结构的栈。</p>
<p>2.堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时<strong>可能</strong>由OS释放。</p>
<p>3.全局区（static）：也叫静态数据内存空间，存储全局变量和静态变量，两个存在一起，但是已经初始化的放一起，没有初始化的放一起。程序结束后由系统释放。</p>
<p>4.文字常量区：常量字符串就是放在这，程序结束后由系统释放。</p>
<p>5.程序代码区：存放函数体的二进制代码。</p>
<p>但是还有的版本是1.2.3相同，<strong>4.5是自由存储区和常量存储区</strong>。</p>
<p><strong>我查了整整一天，发现后面这种其实更符合官方文档。后文会再谈。我这先采用自己的视角探讨内存分配。</strong></p>
<h1 id="可执行程序的文件结构"><a href="#可执行程序的文件结构" class="headerlink" title="可执行程序的文件结构"></a>可执行程序的文件结构</h1><h2 id="C程序"><a href="#C程序" class="headerlink" title="C程序"></a>C程序</h2><p>我在Deepin中用gcc（6.2.0）编译一个hello程序，再用<code>size</code>命令查看其可执行程序的结构，如图：</p>
<p><img src="/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%5CC%E7%BB%93%E6%9E%84.png" alt="C结构"></p>
<p>可以看到，存储时（未加载到内存中）分为代码区（text），数据区（data），未初始化数据区（bss），后面两个是总和2192和2192的十六进制大小。</p>
<p>（1）代码区（text segment）。存放CPU执行的机器指令（machine instructions）。通常，代码区是可共享的（即另外的执行程序可以调用它），因为对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。</p>
<p>（2）全局初始化数据区&#x2F;静态数据区（initialized data segment&#x2F;data segment）。该区包含了在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line"><span class="type">int</span> global=<span class="number">100</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> x=<span class="number">50</span>;</span><br><span class="line"><span class="type">const</span> pi=<span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="type">static</span> <span class="type">int</span>  count=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局变量<code>global</code>,<code>x</code>,全局静态变量<code>x</code>,局部静态变量<code>count</code>,常量<code>pi</code>。<code>global</code>和<code>x</code>的区别在于global可以在该程序的其他文件中使用，而x只在这这个源代码中使用。<code>static</code>有限定只能在当前文件中被调用的作用。</p>
<p>（3）未初始化数据区。亦称BSS区（uninitialized data segment），存入的是全局未初始化变量。BSS这个叫法是根据一个早期的汇编运算符而来，这个汇编运算符标志着一个块的开始。BSS区的数据在程序开始执行之前被内核初始化为0或者空指针（NULL）。例如声明一个数组，但没有赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> sun[<span class="number">1000</span>];</span><br></pre></td></tr></table></figure>

<p><code>long</code>是<code>long int</code>的简写。</p>
<h2 id="C-程序"><a href="#C-程序" class="headerlink" title="C++程序"></a>C++程序</h2><p>在Windows10中用g++(6.3.0)编译C++程序，其结构是和C的一样的</p>
<p><img src="/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%5CC++%E7%BB%93%E6%9E%84.png" alt="c++结构"></p>
<h1 id="运行时的结构"><a href="#运行时的结构" class="headerlink" title="运行时的结构"></a>运行时的结构</h1><p><img src="/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%5C%E6%AF%94%E8%BE%83.jpg" alt="比较"></p>
<p>从上图可以看出，内存空间被分为五个部分。</p>
<p>（1）代码区（text segment）。代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。</p>
<p>代码区的指令中包括操作码和要操作的对象（或对象地址引用）。如果是立即数（即具体的数值，如5），将直接包含在代码中；如果是局部数据，将在栈区分配空间，然后引用该数据地址；如果是BSS区和数据区，在代码中同样将引用该数据地址。</p>
<p>（2）全局初始化数据区&#x2F;静态数据区（Data Segment）。只初始化一次。</p>
<p>（3）未初始化数据区（BSS）。在运行时改变其值。</p>
<p>（4）栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆。</p>
<p>（5）堆区（heap）。用于动态内存分配。堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS回收。</p>
<p>之所以分成这么多个区域，主要基于以下考虑：</p>
<p>一个进程在运行过程中，代码是根据流程依次执行的，只需要访问一次，当然跳转和递归有可能使代码执行多次，而数据一般都需要访问多次，因此单独开辟空间以方便访问和节约空间。</p>
<p>临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。</p>
<p>全局数据和静态数据有可能在整个程序执行过程中都需要访问，因此单独存储管理。</p>
<p>堆区由用户自由分配，以便管理。</p>
<p>C&#x2F;C++语言中典型的存储类型有auto, extern, register, static 这四种，但是是有区别的，C++还有其他两种。存储类型说明了该变量要在进程的哪一个段中分配内存空间，可以为变量分配内存存储空间的有数据区、BBS区、栈区、堆区。下面来一一举例看一下这几个存储类型：</p>
<h2 id="1-auto存储类型"><a href="#1-auto存储类型" class="headerlink" title="1.auto存储类型"></a>1.auto存储类型</h2><p>auto只能用来标识局部变量（’{}’中的部分）的存储类型，对于局部变量，auto是默认的存储类型，不需要显示的指定。因此，auto标识的变量存储在栈区中。示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> i=<span class="number">1</span>; <span class="comment">//显示指定变量的存储类型  </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">2</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i=%d\tj=%d\n&quot;</span>,i,j);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="2-extern存储类型"><a href="#2-extern存储类型" class="headerlink" title="2.extern存储类型"></a>2.extern存储类型</h2><p>extern用来声明在当前文件中引用在当前项目中的其它文件中定义的全局变量。如果全局变量未被初始化，那么将被存在BBS区中，且在编译时，自动将其值赋值为0，如果已经被初始化，那么就被存在数据区中。全局变量，不管是否被初始化，其生命周期都是整个程序运行过程中，为了节省内存空间，在当前文件中使用extern来声明其它文件中定义的全局变量时，就不会再为其分配内存空间。</p>
<p>示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> i=<span class="number">5</span>; <span class="comment">//定义全局变量，并初始化  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in subfunction i=%d\n&quot;</span>,i);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">extern</span> i; <span class="comment">//声明引用全局变量i  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main i=%d\n&quot;</span>,i);  </span><br><span class="line">    test();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -o <span class="built_in">test</span> test.c file.c  <span class="comment">#编译连接</span></span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./test  <span class="comment">#运行</span></span>  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结果：  </span><br><span class="line">  </span><br><span class="line">in main i=5  </span><br><span class="line">in subfunction i=5  </span><br></pre></td></tr></table></figure>

<h2 id="3-register存储类型"><a href="#3-register存储类型" class="headerlink" title="3.register存储类型"></a>3.register存储类型</h2><p>声明为register的变量在由内存调入到CPU寄存器后，则常驻在CPU的寄存器中，因此访问register变量将在很大程度上提高效率，因为省去了变量由内存调入到寄存器过程中的好几个指令周期。如下示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> i,sum=<span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)  </span><br><span class="line">        sum=sum+<span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>但是在 C++11之前，这个关键字在C++中的用法始终未变，只是随着硬件和编译器变得越来越复杂，这种<br>提示表明变量用得很多，编译器可对其做特殊处理。而且寄存器的数量是有限的！</p>
<h2 id="4-static存储类型"><a href="#4-static存储类型" class="headerlink" title="4.static存储类型"></a>4.static存储类型</h2><p>被声明为静态类型的变量，无论是全局的还是局部的，都存储在数据区中，其生命周期为整个程序，如果是静态局部变量，其作用域为一对{}内，如果是静态全局变量，其作用域为当前文件。静态变量如果没有被初始化，则自动初始化为0。静态变量只能够初始化一次。示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> c=<span class="number">0</span>;  </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b=<span class="number">5</span>;  </span><br><span class="line">  </span><br><span class="line">    c++;  </span><br><span class="line">    b++;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,\tc=%d,\tb=%d\t&quot;</span>,a,c,b);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (a+b+c);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="type">int</span> a=<span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum(a)=%d\n&quot;</span>,sum(a));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -o <span class="built_in">test</span> test.c</span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./test</span>   </span><br><span class="line">a=2,    c=1,    b=6 sum(a)=9  </span><br><span class="line">a=2,    c=1,    b=7 sum(a)=10  </span><br><span class="line">a=2,    c=1,    b=8 sum(a)=11  </span><br><span class="line">a=2,    c=1,    b=9	sum(a)=12  </span><br><span class="line">a=2,    c=1,    b=10 sum(a)=13  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-字符串常量"><a href="#5-字符串常量" class="headerlink" title="5.字符串常量"></a>5.字符串常量</h2><p>字符串常量存储在数据区中，其生存期为整个程序运行时间，但作用域为当前文件，示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">char</span> *a=<span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> *c=<span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span>(a==c)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;yes,a==c\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no,a!=c\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> *b=<span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">    <span class="type">char</span> *d=<span class="string">&quot;hello2&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(a==b)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;yes,a==b\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no,a!=b\n&quot;</span>);  </span><br><span class="line">      </span><br><span class="line">    test();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(a==d)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;yes,a==d\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no,a!=d\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -o <span class="built_in">test</span> test.c</span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./test</span>   </span><br><span class="line">yes,a==b  </span><br><span class="line">yes,a==c  </span><br><span class="line">no,a!=d  </span><br></pre></td></tr></table></figure>

<p><strong>由于1~4的类型在C&#x2F;C++中是一样的，所以我用的全是C的代码。</strong></p>
<p><strong>但是在C++11中，<code>auto</code>和<code>register</code>两种都有了新的含义！！！</strong></p>
<p><em>C++11新增了一个工具，让编译器能够根据初始值的类型推断变量的类型。为此，它重新定义了 auto 的含义。auto是一个C 语言关键字，但很少使用，有关其以前的含义，请参阅第9 章。在初始化声明中， 如果使用关键字auto,而不指定变量的类型，编译器将把变量的类型设置成与初始值相同：</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="number">100</span>； <span class="comment">// n is int </span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">1.5</span>； <span class="comment">// x is double </span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">1.3</span>el2L； <span class="comment">// y is long double</span></span><br></pre></td></tr></table></figure>

<p><em>然而，自动推断类型并非为这种简单情况而设计的；事实上，如果将其用于这种简单情形，甚至可能让您误入歧途。例如，假设您要将x、y 和 z 都指定为double类型，并编写了如下代码：</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">0.0</span>； <span class="comment">// ok, x is double because 0.0 is double </span></span><br><span class="line"><span class="type">double</span> y = <span class="number">0</span>； <span class="comment">// ok, 0 automatically converted to 0.0 </span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="number">0</span>; <span class="comment">// oops, z is int because 0 is int</span></span><br></pre></td></tr></table></figure>

<p><em>显式地声明类型时，将变量初始化0 (而不是0.0)不会导致任何问题，但采用自动类型推断时，这却会导致问题。</em><br><em>处理复杂类型，如标准模块库(STL)中的类型时，自动类型推断的有时才能显现出来。例如，对于下述C++98代码：</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; scores； </span><br><span class="line">std::vector&lt;<span class="type">double</span>&gt;::iterator pv = scores.<span class="built_in">begin</span>()；</span><br></pre></td></tr></table></figure>

<p><em>c++n允许您将其重写为下面这样：</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; scores; </span><br><span class="line"><span class="keyword">auto</span> pv = scores.<span class="built_in">begin</span>()；</span><br></pre></td></tr></table></figure>

<p><em>本书后面讨论相关的主题时，将再次提到</em></p>
<p><em>在 C++11之前，这个关键字在C++中的用法始终未变，只是随着硬件和编译器变得越来越复杂，这种提示表明变量用得很多，编译器可对其做特殊处理。在 C++11中，这种提示作用也失去了，关键字register 只是显式地指出变量是自动的。鉴于关键字register只能用于原本就是自动的变量，使用它的唯一原因是， 指出程序员想使用一个自动变量，这个变量的名称可能与外部变量相同。*<em>这与auto以前的用途完全相同。</em></em> 然而，保留关键字register的重要原因是，避免使用了该关键字的现有代码非法。*</p>
<p><em>简而言之，新<code>auto</code>用于自动推断类型，新<code>register</code>的用法则与旧<code>auto</code>一样。</em></p>
<h1 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a>什么是栈？</h1><p>由于自动变量的数目是随着函数的开始和结束而增减的（上面是main函数），因此程序必须在运行时对自动变量进行管理。常用的方法是留出一段内存，将其视为栈，以管理变量的增减。之所以叫栈，是因为新数据被象征性的放在旧数据的上面，即相邻的内存单元。当程序使用完后，将其从栈中删除。栈的默认长度取决于实现，但是可以通过编译器修改。程序使用两个指针来控制栈，一个指向栈底—栈开始的地方；另一个指向栈顶—下一个内存单元。当函数被调用时，其自动变量被加入栈，栈顶指针指向下一个可用的内存单元。函数结束后，栈顶指针被重置为函数被调用之前指向的内存单元，从而释放函数调用使用的自动变量的内存。</p>
<p>栈是LIFO（后进先出）的，即后加入栈中的变量先被弹出。这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。被调用的函数根据其形参描述来确定每个参数的地址。例如，图9.3表明，函数fib()被调用时，传递一个2 字节的int和一个4 字节的long。这些值被加入到栈中。当 fib()开始执行时，它将名称real和 tell同这两个值关联起来。当 fib()结束时，栈顶指针重新指向以 前的位置。新值没有被删除，但不再被标记，它们所占据的空间将被下一个将值加入到栈中的函数调用所<br>使用（图9.3做了简化，因为函数调用可能传递其他信息，如返回地址）。</p>
<p><img src="/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%5C9.3.png" alt="9.3"></p>
<p>注意,栈是从高地址向低地址增长的，大小是有限的。</p>
<h2 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a><strong>栈和堆的区别</strong></h2><p>前面已经介绍过，栈是由编译器在需要时分配的，不需要时自动清除的变量存储区。里面的变量通常是局部变量、函数参数等。堆是由malloc()函数（C++语言为new运算符）分配的内存块，内存释放由程序员手动控制，在C语言为free函数完成（C++中为delete）。栈和堆的主要区别有以下几点：</p>
<h3 id="（1）管理方式不同。"><a href="#（1）管理方式不同。" class="headerlink" title="（1）管理方式不同。"></a><strong>（1）管理方式不同。</strong></h3><p>栈编译器自动管理，无需程序员手工控制；而堆空间的申请释放工作由程序员控制，容易产生内存泄漏。</p>
<h3 id="（2）空间大小不同。"><a href="#（2）空间大小不同。" class="headerlink" title="（2）空间大小不同。"></a><strong>（2）空间大小不同。</strong></h3><p>栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将提示溢出。因此，用户能从栈获得的空间较小。</p>
<p>堆是向高地址扩展的数据结构，是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址。由此可见，堆获得的空间较灵活，也较大。栈中元素都是一一对应的，不会存在一个内存块从栈中间弹出的情况。</p>
<h3 id="（3）是否产生碎片。"><a href="#（3）是否产生碎片。" class="headerlink" title="（3）是否产生碎片。"></a><strong>（3）是否产生碎片。</strong></h3><p>对于堆来讲，频繁的malloc&#x2F;free（new&#x2F;delete）势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低（虽然程序在退出后操作系统会对内存进行回收管理）。对于栈来讲，则不会存在这个问题。</p>
<h3 id="（4）增长方向不同。"><a href="#（4）增长方向不同。" class="headerlink" title="（4）增长方向不同。"></a><strong>（4）增长方向不同。</strong></h3><p>堆的增长方向是向上的，即向着内存地址增加的方向；栈的增长方向是向下的，即向着内存地址减小的方向。</p>
<h3 id="（5）分配方式不同。"><a href="#（5）分配方式不同。" class="headerlink" title="（5）分配方式不同。"></a><strong>（5）分配方式不同。</strong></h3><p>堆都是程序中由malloc()函数动态申请分配并由free()函数释放的；栈的分配和释放是由编译器完成的，栈的动态分配由alloca()函数完成，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行申请和释放的，无需手工实现。</p>
<h3 id="（6）分配效率不同。"><a href="#（6）分配效率不同。" class="headerlink" title="（6）分配效率不同。"></a><strong>（6）分配效率不同。</strong></h3><p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行。堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大的空间，如果没有足够大的空间（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大小的内存，然后返回。显然，堆的效率比栈要低得多。</p>
<h2 id="自由存储区是什么？"><a href="#自由存储区是什么？" class="headerlink" title="自由存储区是什么？"></a>自由存储区是什么？</h2><table>
<thead>
<tr>
<th>内存划分</th>
<th>运行时结构</th>
</tr>
</thead>
<tbody><tr>
<td>栈（stack）</td>
<td>栈</td>
</tr>
<tr>
<td>堆（heap）</td>
<td>堆</td>
</tr>
<tr>
<td>全局&#x2F;静态存储区</td>
<td>未初始化数据（BSS）</td>
</tr>
<tr>
<td>自由存储区</td>
<td>数据区（data）</td>
</tr>
<tr>
<td>常量存储区</td>
<td>代码区</td>
</tr>
</tbody></table>
<p>常量存储区和全局／静态存储区对应着数据区。BSS和代码区没有对应。而自由存储区在某种程度上可以视为堆的一部分。</p>
<h3 id="“free-store”-VS-“heap”"><a href="#“free-store”-VS-“heap”" class="headerlink" title="“free store” VS “heap”"></a>“free store” VS “heap”</h3><p>当我问你C++的内存布局时，你大概会回答：</p>
<p><em>“在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局&#x2F;静态存储区、常量存储区”。</em></p>
<p>如果我接着问你自由存储区与堆有什么区别，你或许这样回答：</p>
<p><em>“malloc在堆上分配的内存块，使用free释放内存，而new所申请的内存则是在自由存储区上，使用delete来释放。”</em></p>
<p>这样听起来似乎也没错，但如果我接着问：</p>
<p><em>自由存储区与堆是两块不同的内存区域吗？它们有可能相同吗？</em></p>
<p>你可能就懵了。</p>
<p>事实上，我在网上看的很多博客，划分自由存储区与堆的分界线就是new&#x2F;delete与malloc&#x2F;free。然而，尽管C++标准没有要求，但很多编译器的new&#x2F;delete都是以malloc&#x2F;free为基础来实现的。那么请问：借以malloc实现的new，所申请的内存是在堆上还是在自由存储区上？</p>
<p>从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。**<u>基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。</u>**但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。我们所需要记住的就是：</p>
<p>堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。</p>
<h3 id="问题的来源"><a href="#问题的来源" class="headerlink" title="问题的来源"></a>问题的来源</h3><p>再回过头来来看看这个问题的起源在哪里。最先我们使用C语言的时候，并没有这样的争议，很明确地知道malloc&#x2F;free是在堆上进行内存操作。直到我们在Bjarne Stroustrup的书籍中数次看到free store （自由存储区）,说实话，我一直把自由存储区等价于堆。而在Herb Sutter的《exceptional C++》中，明确指出了free store（自由存储区） 与 heap（堆） 是有区别的。关于自由存储区与堆是否等价的问题讨论，大概就是从这里开始的：</p>
<p><em>Free Store</em><br><em>The free store is one of the two dynamic memory areas, allocated&#x2F;freed by new&#x2F;delete. Object lifetime can be less than the time the storage is allocated; that is, free store objects can have memory allocated without being immediately initialized, and can be destroyed without the memory being immediately deallocated. During the period when the storage is allocated but outside the object’s lifetime, the storage may be accessed and manipulated through a void</em> but none of the proto-object’s nonstatic members or member functions may be accessed, have their addresses taken, or be otherwise manipulated.*</p>
<p><em>Heap</em><br><em>The heap is the other dynamic memory area, allocated&#x2F;freed by malloc&#x2F;free and their variants. Note that while the default global new and delete might be implemented in terms of malloc and free by a particular compiler, the heap is not the same as free store and memory allocated in one area cannot be safely deallocated in the other. Memory allocated from the heap can be used for objects of class type by placement-new construction and explicit destruction. If so used, the notes about free store object lifetime apply similarly here.</em></p>
<p>来源：<a target="_blank" rel="noopener" href="http://www.gotw.ca/gotw/009.htm">http://www.gotw.ca/gotw/009.htm</a></p>
<p>作者也指出，之所以把堆与自由存储区要分开来，是因为在C++标准草案中关于这两种区域是否有联系的问题一直很谨慎地没有给予详细说明，而且特定情况下new和delete是按照malloc和free来实现，或者说是放过来malloc和free是按照new和delete来实现的也没有定论。这两种内存区域的运作方式不同、访问方式不同，所以应该被当成不一样的东西来使用。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>自由存储是C++中通过new与delete动态分配和释放对象的<strong>抽象概念</strong>，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。</li>
<li>new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。</li>
<li>堆与自由存储区还是有区别的，它们并非等价。</li>
</ul>
<p>假如你来自C语言，从没接触过C++；或者说你一开始就熟悉C++的自由储存概念，而从没听说过C语言的malloc，可能你就不会陷入“自由存储区与堆好像一样，好像又不同”这样的迷惑之中。这就像Bjarne Stroustrup所说的：</p>
<blockquote>
<p>usually because they come from a different language background.</p>
</blockquote>
<p>大概只是语言背景不同罢了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th>分配方式1</th>
<th>分配方式2</th>
<th>运行时结构</th>
</tr>
</thead>
<tbody><tr>
<td>栈</td>
<td>栈</td>
<td>栈</td>
</tr>
<tr>
<td>堆</td>
<td>堆</td>
<td>堆</td>
</tr>
<tr>
<td>自由存储区</td>
<td>文字常量区（所有常量）</td>
<td>BSS</td>
</tr>
<tr>
<td>全局&#x2F;静态存储区</td>
<td>全局&#x2F;静态存储区</td>
<td>Data</td>
</tr>
<tr>
<td>常量存储区（包括字符）</td>
<td>程序代码区</td>
<td>代码区</td>
</tr>
</tbody></table>
<p><strong>2</strong>与<strong>1</strong>相比就是把自由存储区加到了堆中，再加了个代码区。两种方式孰优孰劣？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/01/30/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D/" data-id="cltr7hcaf002u0kun9g45dimb" data-title="内存空间分配" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/02/01/%E6%95%B0%E7%BB%84%E6%8B%BE%E9%81%97/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数组拾遗
        
      </div>
    </a>
  
  
    <a href="/2018/01/29/%E6%8C%87%E9%92%88%E6%8E%A2%E5%B9%BD1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">指针探幽1</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenCV/" rel="tag">OpenCV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VS/" rel="tag">VS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/VS/" style="font-size: 10px;">VS</a> <a href="/tags/cpp/" style="font-size: 17.5px;">cpp</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 15px;">汇编</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 12.5px;">网络</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 12.5px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/08/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</a>
          </li>
        
          <li>
            <a href="/2018/11/03/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-2/">网络原理(2)</a>
          </li>
        
          <li>
            <a href="/2018/10/26/html%E6%80%BB%E7%BB%93/">html总结</a>
          </li>
        
          <li>
            <a href="/2018/10/25/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-1/">网络原理(1)</a>
          </li>
        
          <li>
            <a href="/2018/08/18/Java%E7%9A%84JDBC/">Java的JDBC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>